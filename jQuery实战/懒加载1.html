<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>瀑布流</title>
    <style>
       *{
           margin: 0;
           padding: 0;
       }
       a{
           text-decoration: none;
           color: #333333;
       }
       ul,li{
           list-style: none;
       }
       body{
           font-size: 14px;
           font-family: "微软雅黑";
           background: #336688
       }
       .ml15{
           margin-left: 15px;
       }
       .mr15{
           margin-right: 15px;
       }
       .container{
           margin: 30px auto;
           position: relative;
           width: 100%;
       }
       .move{
           width: 200px;
           display: flex;
           flex-direction: column;
           box-shadow: 1px 1px 1em #dddddd;
           position: absolute;
           top:0;
           left: 0;
           transition:  1s;
       }
       .move img, .move a{
           display: block;
       }
       .move .year{
           height: 30px;
           line-height: 30px;
           background: #f7e9ee;
           display: flex;
           justify-content: space-between;
       }
       .move .year span {
           text-align: right;
       }
       .move .move_info{
           display: flex;
           justify-content: space-between;
           background: #f7e9ee;
           padding-bottom: 5px;
       }
    </style>
</head>

<body>
    <div class="container"></div>
    <!-- 
        缓存代理懒加载瀑布流：
            需求分析：
                获取数据 渲染到页面 滚动滚动条判断临界点去动态加载数据
            技术实现：
                1、获取数据：通过接口
                    ajax jsonp
                    地址 url
                    http://api.douban.com/v2/movie/top250
                    回调函数  =>获取返回的数据
                2、解析数据
                es6 forEach 迭代
                    item 每一条数据
                3、jsDOM解析
                    动态生成DOM节点
                        1、创建节点
                            createElemet
                            初始化属性
                            数据绑定
                            ES6 `` ${}

                4、瀑布流的定位算法
                    核心思路：列数为基准，找出列数高度最小的那一列往下添加图片
                    技术实现：
                        1、初始化，一行有几列
                        2、数组操作
                            arrTOP 存放当前top
                            arrLeft 存放当前left
                        3、不断的利用递归来更新高度值

                5、懒加载

     -->
     
</body>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<script>
    //1、获取数据：通过接口
    var url = 'http://api.douban.com/v2/movie/top250';
    //获取.containerDIV
    var oCon = document.querySelector(".container");
    //设置一个列表的宽度
    var width =200;
    //设置一个间距的宽度
    var space = 10;
    //初始化一栏列表的数目
    var num = 0;
    //一个列表的总长度
    var totalWidth = width + space;
    //设置一个arrTop存放当前top
    var arrTop = [];
    //设置一个arrLeft存放当前left
    var arrLeft = [];

    cells()
    //遍历一行的列数
    for(var i = 0 ; i < num ; i++){
        //获取到的列表的top存入arrTop中，初始化0
        arrTop.push(0);
        //获取到的列表的总长度存入arrLeft中
        arrLeft.push(i * totalWidth);
    }
    //初始化操作
    function cells() {
        //求出一行列表的数目
        num = Math.floor(window.innerWidth / totalWidth);
        //设置oCon的宽度，让布局居中
        oCon.style.width = num * totalWidth - space + 'px'
        // console.log(num)
    }
    // alert(oCon)
    getData({
        //获取url
        url:url + '?start=0&count=100',
        //数据类型
        dataType:'jsonp',
        callback:function(data){
            // console.log(data)
            //创建一个对象保存解析的数据
            var movieData = resloveMovieData(data);
            // console.log(movieData)
            //对数据进行绑定
            formatData(movieData)
        }
    })
    //获取数据的业务模块
    function getData(opt){
        $.ajax({
            //获取url地址==>数据参数
            url:opt.url,
            //数据类型
            dataType:opt.dataType,
            //返回数据
            success:function(res){
                //判断 如果不存在回调函数，不执行
                opt['callback'] && opt['callback'](res.subjects);
                
            }
        })
    }

    //2、解析数据模块  data向后台发送的数据
    function resloveMovieData(data){
        //创建一个数组
        var movie = [];
        //解析每一条数据 用es6迭代
        data.forEach(function(item){
            //遍历的每一条数据添加到movie数组中
            movie.push({
                //接口对应的数据
                title: item.title || '未命名',
                original_title:item.original_title || '原名',
                score:item.rating.average || '未评分',
                year:item.year || '未出版',
                coverImg:item.images.large || item.images.medium || item.images.small
            });
            // console.log(item.images)
        });
        //返回一个数组
        return movie;
    }

    //3、jsDOM解析 ==> 模板渲染 数据绑定
    function formatData(info){
        //初始化数据长度
        var i = 0;
        //一开始要加载的数据长度
        var length = 100;
        //递归操作
        (function recur(){
            //创建一个div
            var oDiv = document.createElement('div');
            //获取每一条的数据赋值给item
            var item = info[i];
            //得到一个最小高度的序列号  ...==>es6数组  扩展运算符
            var minIndex = arrTop.indexOf(Math.min(...arrTop));
            //给oDiv添加一个move类名
            oDiv.className = 'move';
            //字符串拼接 ``es6拼接
            oDiv.innerHTML = `<a href="#" target="blank">
                <img class="pic" src="${item.coverImg}" width="200" height="auto"></a>
                <p class="year">
                    <i class="ml15">${item.year}</i>
                    <span class="mr15">${item.original_title}</span>
                </p>
                <p class="move_info">
                    <span class="title ml15">${item.title}</span>
                    <span class="score mr15">${item.score}</span>
                </p>`;
                //oDiv添加到oCon
                oCon.appendChild(oDiv)
                //代码执行速度比api请求数据快，会造成i的覆盖
                oDiv.querySelector(".pic").onload = function(){
                    //left偏移
                    oDiv.style.left = arrLeft[minIndex] + 'px';
                    //top偏移
                    oDiv.style.top = arrTop[minIndex] + 'px';
                    //最小高度累加
                    arrTop[minIndex] += oDiv.offsetHeight + space; 
                    //每次累加一次
                    i++;
                    //进行判断
                    i < length && recur();
                    
                    // console.log(i);

                    
                };
        })()



       
    }

    //懒加载

    
    


    /*
        ~function(){}
        (function(){})()
        IIFE：函数匿名立刻执行
    */


</script>
</html>
